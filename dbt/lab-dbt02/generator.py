import random
import csv
import json
from datetime import date, timedelta, datetime
from faker import Faker
import argparse
import os

# --- Configuration ---
LOCALES = ['en_GB', 'de_DE', 'fr_FR', 'es_ES', 'it_IT', 'pl_PL', 'de_AT', 'de_CH', 'de_DE']
DEFAULT_NUM_CUSTOMERS = 100
DEFAULT_CUSTOMERS_OFFSET = 1
DEFAULT_START_DATE = date(2016, 1, 1)
DEFAULT_END_DATE = date(2024, 12, 31)
DEFAULT_CUSTOMERS_OUTPUT = "customers.csv"
DEFAULT_TRANSACTIONS_OUTPUT = "transactions.json"
DEFAULT_TRANSACTIONS_OFFSET = 1
DEFAULT_BOOKS_INPUT = "books.csv" # Default input for book data

# Initialize Faker
fake = Faker(LOCALES) # Initialize with multiple locales for diversity

# --- Function Definitions ---

def generate_customers(num_customers, output_file, customers_offset):
    """
    Generates synthetic customer data using the Faker library and writes it to a CSV file.

    Args:
        num_customers (int): The number of customer records to generate.
        output_file (str): The path to the CSV file where customer data will be saved.

    Returns:
        list[dict]: A list of dictionaries, where each dictionary represents a generated customer.
                    Returns an empty list if num_customers is 0 or less.
    """
    if num_customers <= 0:
        print("Number of customers must be positive.")
        return []

    print(f"Generating {num_customers} customers to {output_file}...")
    header = [
        "customer_id", "first_name", "last_name", "email", "phone_number",
        "address", "city", "country", "postal_code", "age", "gender",
        "registration_date", "related_accounts"
    ]
    customers_data = []
    try:
        with open(output_file, mode='w', newline='', encoding='utf-8') as file:
            writer = csv.writer(file)
            writer.writerow(header)

            for customer_id in range(customers_offset, num_customers + 1 + customers_offset):
                locale = random.choice(LOCALES)
                # Temporarily set locale for this customer for better geographical consistency
                current_faker = Faker(locale)
                first_name = current_faker.first_name()
                last_name = current_faker.last_name()
                email = current_faker.email()
                phone_number = current_faker.phone_number()
                address = current_faker.street_address().replace('\n', '\\n') # Handle multi-line addresses
                city = current_faker.city()
                # Get country from the current locale if possible, otherwise use default faker
                try:
                    # Use current_country_code and convert to country name or use country() directly
                    country = current_faker.country()
                except AttributeError: # Fallback if specific methods aren't available
                     country = fake.country() # Use the general pool faker

                postal_code = current_faker.postcode()
                age = random.randint(18, 80)
                gender = random.choice(['Male', 'Female', 'Other'])
                # Ensure registration date is plausible (e.g., not in the future, within last N years)
                max_reg_days_ago = (date.today() - date(2010, 1, 1)).days # Example: up to ~15 years ago
                reg_days_ago = random.randint(1, max(1, max_reg_days_ago)) # Ensure at least 1 day ago
                registration_date = date.today() - timedelta(days=reg_days_ago)

                related_accounts = [str(random.randint(1000, 9999)) for _ in range(random.randint(0, 3))]
                related_accounts_string = ','.join(related_accounts)

                row = [
                    customer_id, first_name, last_name, email, phone_number,
                    address, city, country, postal_code, age, gender,
                    registration_date.strftime('%Y-%m-%d'), related_accounts_string
                ]
                writer.writerow(row)
                # Store customer data as dict for potential immediate transaction generation
                customers_data.append(dict(zip(header, row)))

        print(f"Customer data saved successfully to '{output_file}'.")
    except IOError as e:
        print(f"Error writing customer file {output_file}: {e}")
        return [] # Return empty list on error
    except Exception as e:
        print(f"An unexpected error occurred during customer generation: {e}")
        return []
    return customers_data

def generate_transactions(customers_data, books_data, start_date, end_date, output_file, transaction_offset):
    """
    Generates synthetic transaction data based on provided customer and book data,
    writing the output to a newline-delimited JSON file.

    Transactions are generated probabilistically for each customer between the
    specified start and end dates (or customer's registration date, whichever is later).

    Args:
        customers_data (list[dict]): A list of customer dictionaries (as generated by
                                     generate_customers or loaded by load_customers).
                                     Each dict must have 'customer_id' and 'registration_date'.
        books_data (list[dict]): A list of book dictionaries. Each dict must have 'book_id'.
                                 If empty or None, dummy book IDs might be used with a warning.
        start_date (date): The earliest possible date for any transaction.
        end_date (date): The latest possible date for any transaction.
        output_file (str): The path to the newline-delimited JSON file where transaction
                           data will be saved.

    Returns:
        None. Prints status messages and errors to the console.
    """
    print(f"Generating transactions from {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')} into {output_file}...")
    transactions = []
    transaction_id = transaction_offset

    if not customers_data:
        print("Error: No customer data provided. Cannot generate transactions.")
        return
    if not books_data:
        print("Warning: No book data loaded. Transactions will not have valid 'book_id' values.")
        # Define books_data as empty list to prevent errors later, but note the limitation
        books_data = []


    for customer in customers_data:
        try:
            # Ensure customer_id is correctly accessed (it might be string or int depending on source)
            customer_id_str = str(customer['customer_id'])
            registration_date_str = customer['registration_date']
            registration_date = date.fromisoformat(registration_date_str)
        except (KeyError, ValueError) as e:
            print(f"Skipping customer due to missing/invalid data (customer_id or registration_date): {customer}. Error: {e}")
            continue # Skip this customer if essential data is missing or invalid

        # Transaction period starts at the later of global start date or customer registration date
        trans_start_date = max(registration_date, start_date)

        # Skip customer if their registration is after the transaction end date
        if trans_start_date > end_date:
            continue

        current_date = trans_start_date
        while current_date <= end_date:
            # Probability of making a transaction in a given ~monthly interval
            if random.random() < 0.3: # Approx. 30% chance per interval
                # Generate transaction date somewhere within the next interval (approx month)
                # Ensure it doesn't exceed the end_date
                max_days_offset = (end_date - current_date).days
                if max_days_offset < 0: break # Stop if current_date somehow passed end_date
                days_offset = random.randint(0, min(27, max_days_offset)) # Random day within ~month, capped by end_date
                transaction_date = current_date + timedelta(days=days_offset)

                items = []
                num_items_in_transaction = random.randint(1, 5)
                for _ in range(num_items_in_transaction):
                    unit_price = round(random.uniform(5.99, 49.99), 2)
                    quantity = random.choices([1, 2, 3], [0.8, 0.15, 0.05])[0] # More likely to buy 1 item

                    # Safely select a book_id if book data is available
                    if books_data:
                         book_id = random.choice(books_data)['index']
                    else:
                         book_id = "UNKNOWN" # Placeholder if no book data

                    items.append({
                        "book_id": book_id,
                        "unit_price": unit_price,
                        "quantity": quantity,
                    })

                if not items: continue # Skip if no items were added (shouldn't happen here)

                cash_register = random.randint(1, 50)
                cashier = f'{cash_register}-{random.randint(1, 5)}'

                transactions.append({
                    "transaction_id": transaction_id,
                    "customer_id": customer_id_str, # Use the validated string ID
                    "transaction_date": transaction_date.strftime('%Y-%m-%d'),
                    "items": items,
                    "cash_register": cash_register,
                    "cashier": cashier
                })
                transaction_id += 1

            # Advance to the next ~monthly interval with random variation
            current_date += timedelta(days=random.randint(25, 40))

    # Write transaction data to new line delimited JSON file
    try:
        with open(output_file, mode='w', encoding='utf-8') as file:
            for transaction in transactions:
                file.write(json.dumps(transaction) + '\n')
        print(f"Transaction data saved successfully to '{output_file}'. Total transactions generated: {len(transactions)}")
    except IOError as e:
        print(f"Error writing transaction file {output_file}: {e}")
    except Exception as e:
        print(f"An unexpected error occurred during transaction writing: {e}")


def load_customers(input_file):
    """
    Loads customer data from a specified CSV file.

    Assumes the CSV file has a header row corresponding to the keys
    in the dictionaries it yields. Requires 'customer_id' and 'registration_date'.

    Args:
        input_file (str): The path to the customer CSV file.

    Returns:
        list[dict] | None: A list of dictionaries, where each dictionary represents
                           a customer read from the file. Returns None if the file
                           cannot be found or read.
    """
    print(f"Loading customers from {input_file}...")
    customers = []
    try:
        with open(input_file, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            if not reader.fieldnames or 'customer_id' not in reader.fieldnames or 'registration_date' not in reader.fieldnames:
                 print(f"Error: Customer file {input_file} is missing required headers ('customer_id', 'registration_date').")
                 return None
            for row in reader:
                customers.append(row)
        print(f"Successfully loaded {len(customers)} customers.")
    except FileNotFoundError:
        print(f"Error: Customer file not found at {input_file}")
        return None
    except Exception as e:
        print(f"Error reading customer file {input_file}: {e}")
        return None
    return customers

def load_books(input_file):
    """
    Loads book data from a specified CSV file.

    Assumes the CSV file has a header row and requires at least a 'book_id' column.

    Args:
        input_file (str): The path to the book CSV file.

    Returns:
        list[dict] | None: A list of dictionaries representing books. Returns an empty list
                           if the file is not found (issues a warning). Returns None
                           if there's a critical reading error or missing 'book_id' header.
    """
    print(f"Loading books from {input_file}...")
    books = []
    try:
        with open(input_file, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            # Basic validation: Check for 'index' column
            if not reader.fieldnames or 'index' not in reader.fieldnames:
                 print(f"Error: Required header 'index' not found in book file {input_file}.")
                 return None # Critical error if index is missing
            for row in reader:
                # Optional: Add more validation for book data if needed here
                books.append(row)
        print(f"Successfully loaded {len(books)} books.")
    except FileNotFoundError:
        # Non-critical if book file is missing, allow proceeding without book details
        print(f"Warning: Book file not found at {input_file}. Proceeding without specific book details in transactions.")
        return [] # Return empty list, transactions will use placeholders
    except Exception as e:
        print(f"Error reading book file {input_file}: {e}")
        return None # Indicate a critical error occurred during file reading
    return books

# --- Argument Parsing ---
def parse_arguments():
    """
    Parses command-line arguments for the data generation script.

    Defines arguments for controlling the generation process, input/output files,
    and data parameters (like number of customers, date ranges). Includes validation
    for date logic and required input files based on the generation mode.

    Returns:
        argparse.Namespace: An object containing the parsed command-line arguments.
                            Exits the script if invalid arguments are provided.
    """
    # Add a description that will be shown with --help
    parser = argparse.ArgumentParser(
        description="""
        Generate synthetic customer and/or transaction data.
        Customers are saved in CSV format, transactions in newline-delimited JSON (NDJSON).
        Requires Faker library. Ensure 'books.csv' exists for realistic transaction item data.
        """,
        formatter_class=argparse.RawTextHelpFormatter # Preserve formatting in description
        )

    parser.add_argument(
        "--generate",
        choices=['customers', 'transactions', 'all'],
        default='all',
        help="Specify what to generate:\n"
             "  'customers': Generate only customer data.\n"
             "  'transactions': Generate only transaction data (requires --customers-input).\n"
             "  'all': Generate customers and then transactions (default)."
    )
    parser.add_argument(
        "--num-customers",
        type=int,
        default=DEFAULT_NUM_CUSTOMERS,
        help=f"Number of customers to generate (default: {DEFAULT_NUM_CUSTOMERS}).\n"
             "Used if --generate is 'customers' or 'all'."
    )
    parser.add_argument(
        "--customers-offset",
        type=int,
        default=DEFAULT_CUSTOMERS_OFFSET,
        help=f"Customer id offset to generate (default: {DEFAULT_CUSTOMERS_OFFSET}).\n"
             "Used if --generate is 'customers' or 'all'."
    )
    parser.add_argument(
        "--start-date",
        type=lambda s: datetime.strptime(s, '%Y-%m-%d').date(),
        default=DEFAULT_START_DATE,
        help=f"Start date for transactions (YYYY-MM-DD format).\n"
             f"Default: {DEFAULT_START_DATE.strftime('%Y-%m-%d')}."
    )
    parser.add_argument(
        "--end-date",
        type=lambda s: datetime.strptime(s, '%Y-%m-%d').date(),
        default=DEFAULT_END_DATE,
        help=f"End date for transactions (YYYY-MM-DD format).\n"
             f"Default: {DEFAULT_END_DATE.strftime('%Y-%m-%d')}."
    )
    parser.add_argument(
        "--customers-input",
        type=str,
        default=DEFAULT_CUSTOMERS_OUTPUT, # Default input is the default output of customer gen
        help="Path to the input CSV file containing customer data.\n"
             "Required if --generate is 'transactions'.\n"
             f"Default: {DEFAULT_CUSTOMERS_OUTPUT}"
    )
    parser.add_argument(
        "--customers-output",
        type=str,
        default=DEFAULT_CUSTOMERS_OUTPUT,
        help=f"Path for the output customer CSV file.\n"
             "Used if --generate is 'customers' or 'all'.\n"
             f"Default: {DEFAULT_CUSTOMERS_OUTPUT}"
    )
    parser.add_argument(
        "--transactions-output",
        type=str,
        default=DEFAULT_TRANSACTIONS_OUTPUT,
        help=f"Path for the output transactions JSON file (newline-delimited).\n"
             "Used if --generate is 'transactions' or 'all'.\n"
             f"Default: {DEFAULT_TRANSACTIONS_OUTPUT}"
    )
    parser.add_argument(
        "--transactions-offset",
        type=int,
        default=DEFAULT_CUSTOMERS_OFFSET,
        help=f"Transactions id offset to generate (default: {DEFAULT_CUSTOMERS_OFFSET}).\n"
             "Used if --generate is 'transactions' or 'all'."
    )
    parser.add_argument(
        "--books-input",
        type=str,
        default=DEFAULT_BOOKS_INPUT,
        help="Path to the input CSV file containing book data (requires 'index' header).\n"
             f"Used if generating transactions. Default: {DEFAULT_BOOKS_INPUT}"
    )

    args = parser.parse_args()

    # --- Post-parsing Validation ---
    if args.start_date > args.end_date:
        parser.error("Constraint violated: --start-date cannot be after --end-date.")

    # Check if customer input file exists ONLY if we are generating ONLY transactions
    if args.generate == 'transactions':
        if not os.path.exists(args.customers_input):
            parser.error(f"Customer input file specified (--customers-input {args.customers_input}) not found. "
                         "This file is required when --generate is set to 'transactions'.")
        # Optional: Add a check if customers_input is the same as customers_output when generate='transactions'
        #           which might indicate user confusion, but could be valid.

    return args

# --- Main Execution ---
if __name__ == "__main__":
    """
    Main execution block. Parses arguments, loads/generates data based on the
    '--generate' flag, and calls the appropriate functions.
    """
    args = parse_arguments()

    customers = None # Initialize customers variable
    books = None # Initialize books variable

    # Load book data first if transactions are involved
    if args.generate in ['transactions', 'all']:
         books = load_books(args.books_input)
         if books is None: # Check if book loading failed critically (e.g., bad format, missing header)
              print("Exiting: Critical error loading book data. Please check the book file and path.")
              exit(1) # Exit script if essential book data structure is wrong

    # --- Step 1: Generate or Load Customers ---
    if args.generate in ['customers', 'all']:
        # Generate new customers
        customers = generate_customers(args.num_customers, args.customers_output, args.customers_offset)
        if not customers: # Check if customer generation failed
             print("Exiting: Customer generation failed or produced no data.")
             exit(1)
    elif args.generate == 'transactions':
        # Load existing customers
        customers = load_customers(args.customers_input)
        if customers is None: # Check if customer loading failed critically
             print("Exiting: Failed to load customer data required for transaction generation.")
             exit(1)

    # --- Step 2: Generate Transactions ---
    # This step runs if 'all' or 'transactions' was specified, AND if customer data is available.
    if args.generate in ['transactions', 'all']:
        if customers: # Ensure customer data (either loaded or generated) exists
            generate_transactions(customers, books, args.start_date, args.end_date, args.transactions_output, args.transactions_offset)
        else:
            # This condition implies an issue in the logic flow or previous error handling
            print("Error: Cannot generate transactions because customer data is unavailable. This might indicate an earlier failure.")
            exit(1) # Exit with error if we reach here without customer data

    print("\nData generation process finished.")
    exit(0) # Explicitly exit with success code